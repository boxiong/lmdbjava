/*-
 * #%L
 * LmdbJava
 * %%
 * Copyright (C) 2016 - 2019 The LmdbJava Open Source Project
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */

package org.lmdbjava;

import java.io.*;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.FileChannel;

import org.lmdbjava.schema.*;
import com.google.flatbuffers.ByteBufferUtil;
import com.google.flatbuffers.FlatBufferBuilder;

import static com.google.flatbuffers.Constants.*;

import org.junit.Assert;
import org.junit.Test;

public class BxFlatBufferTest {

  @Test
  public void testEntryPoint() {

      // First, let's test reading a FlatBuffer generated by C++ code:
      // This file was generated from monsterdata_test.json
      byte[] data = null;
      File file = new File("/tmp/bx/monsterdata_test.mon");
      RandomAccessFile f = null;
      try {
          f = new RandomAccessFile(file, "r");
          data = new byte[(int)f.length()];
          f.readFully(data);
          f.close();
      } catch(java.io.IOException e) {
          System.out.println("FlatBuffers test: couldn't read file");
          return;
      }

      // Now test it:
      ByteBuffer bb = ByteBuffer.wrap(data);
      testBuffer(bb);

      // Second, let's create a FlatBuffer from scratch in Java, and test it also.
      // We use an initial size of 1 to exercise the reallocation algorithm,
      // normally a size larger than the typical FlatBuffer you generate would be
      // better for performance.
      FlatBufferBuilder fbb = new FlatBufferBuilder(1);

      testBuilderBasics(fbb, true);
      testBuilderBasics(fbb, false);

      testCreateByteVector();

      testCreateUninitializedVector();

      testByteBufferFactory();

      testSizedInputStream();

      System.out.println("FlatBuffers test: completed successfully");
  }

  void testEnums() {
    testEq(Color.name(Color.Red), "Red");
    testEq(Color.name(Color.Blue), "Blue");
  }

  void testBuffer(ByteBuffer bb) {
      Monster monster = Monster.getRootAsMonster(bb);

      testEq(monster.hp(), (short)80);
      testEq(monster.mana(), (short)150);  // default

      testEq(monster.name(), "MyMonster");
      // monster.friendly() // can't access, deprecated

      Vec3 pos = monster.pos();
      testEq(pos.x(), 1.0f);
      testEq(pos.y(), 2.0f);
      testEq(pos.z(), 3.0f);

      testEq(monster.inventoryLength(), 5);
      int invsum = 0;
      for (int i = 0; i < monster.inventoryLength(); i++)
          invsum += monster.inventory(i);
      testEq(invsum, 10);

      // Alternative way of accessing a vector:
      ByteBuffer ibb = monster.inventoryAsByteBuffer();
      invsum = 0;
      while (ibb.position() < ibb.limit())
          invsum += ibb.get();
      testEq(invsum, 10);
  }

  void testCreateByteVector() {
      FlatBufferBuilder fbb = new FlatBufferBuilder(16);
      int str = fbb.createString("MyMonster");
      byte[] inventory = new byte[] { 0, 1, 2, 3, 4 };
      int vec = fbb.createByteVector(inventory);
      Monster.startMonster(fbb);
      Monster.addInventory(fbb, vec);
      Monster.addName(fbb, str);
      int monster1 = Monster.endMonster(fbb);
      Monster.finishMonsterBuffer(fbb, monster1);

      Monster monsterObject = Monster.getRootAsMonster(fbb.dataBuffer());
      testEq(monsterObject.inventory(1), (int)inventory[1]);
      testEq(monsterObject.inventoryLength(), inventory.length);
      testEq(ByteBuffer.wrap(inventory), monsterObject.inventoryAsByteBuffer());
  }

  void testCreateUninitializedVector() {
      FlatBufferBuilder fbb = new FlatBufferBuilder(16);
      int str = fbb.createString("MyMonster");
      byte[] inventory = new byte[] { 0, 1, 2, 3, 4 };
      ByteBuffer bb = fbb.createUnintializedVector(1, inventory.length, 1);
      for (byte i:inventory) {
          bb.put(i);
      }
      int vec = fbb.endVector();
      Monster.startMonster(fbb);
      Monster.addInventory(fbb, vec);
      Monster.addName(fbb, str);
      int monster1 = Monster.endMonster(fbb);
      Monster.finishMonsterBuffer(fbb, monster1);

      Monster monsterObject = Monster.getRootAsMonster(fbb.dataBuffer());
      testEq(monsterObject.inventory(1), (int)inventory[1]);
      testEq(monsterObject.inventoryLength(), inventory.length);
      testEq(ByteBuffer.wrap(inventory), monsterObject.inventoryAsByteBuffer());
  }

  void testByteBufferFactory() {
      final class MappedByteBufferFactory implements FlatBufferBuilder.ByteBufferFactory {
          @Override
          public ByteBuffer newByteBuffer(int capacity) {
              ByteBuffer bb;
              try {
                  bb =  new RandomAccessFile("/tmp/bx/javatest.bin", "rw").getChannel().map(FileChannel.MapMode.READ_WRITE, 0, capacity).order(ByteOrder.LITTLE_ENDIAN);
              } catch(Throwable e) {
                  System.out.println("FlatBuffers test: couldn't map ByteBuffer to a file");
                  bb = null;
              }
              return bb;
          }
      }

      FlatBufferBuilder fbb = new FlatBufferBuilder(1, new MappedByteBufferFactory());

      testBuilderBasics(fbb, false);
  }

  void testSizedInputStream() {
      // Test on default FlatBufferBuilder that uses HeapByteBuffer
      FlatBufferBuilder fbb = new FlatBufferBuilder(1);

      testBuilderBasics(fbb, false);

      InputStream in = fbb.sizedInputStream();
      byte[] array = fbb.sizedByteArray();
      int count = 0;
      int currentVal = 0;

      while (currentVal != -1 && count < array.length) {
          try {
              currentVal = in.read();
          } catch(java.io.IOException e) {
              System.out.println("FlatBuffers test: couldn't read from InputStream");
              return;
          }
          testEq((byte)currentVal, array[count]);
          count++;
      }
      testEq(count, array.length);
  }

  void testBuilderBasics(FlatBufferBuilder fbb, boolean sizePrefix) {
      int[] names = {fbb.createString("Frodo"), fbb.createString("Barney"), fbb.createString("Wilma")};
      int[] off = new int[3];
      Monster.startMonster(fbb);
      Monster.addName(fbb, names[0]);
      off[0] = Monster.endMonster(fbb);
      Monster.startMonster(fbb);
      Monster.addName(fbb, names[1]);
      off[1] = Monster.endMonster(fbb);
      Monster.startMonster(fbb);
      Monster.addName(fbb, names[2]);
      off[2] = Monster.endMonster(fbb);
      int sortMons = fbb.createSortedVectorOfTables(new Monster(), off);

      // We set up the same values as monsterdata.json:

      int str = fbb.createString("MyMonster");

      int inv = Monster.createInventoryVector(fbb, new byte[] { 0, 1, 2, 3, 4 });

      int fred = fbb.createString("Fred");
      Monster.startMonster(fbb);
      Monster.addName(fbb, fred);
      int mon2 = Monster.endMonster(fbb);

      Monster.startMonster(fbb);
      Monster.addPos(fbb, Vec3.createVec3(fbb, 1.0f, 2.0f, 3.0f));
      Monster.addHp(fbb, (short)80);
      Monster.addName(fbb, str);
      Monster.addInventory(fbb, inv);
      int mon = Monster.endMonster(fbb);

      if (sizePrefix) {
          Monster.finishSizePrefixedMonsterBuffer(fbb, mon);
      } else {
          Monster.finishMonsterBuffer(fbb, mon);
      }

      // Write the result to a file for debugging purposes:
      // Note that the binaries are not necessarily identical, since the JSON
      // parser may serialize in a slightly different order than the above
      // Java code. They are functionally equivalent though.

      try {
          String filename = "/tmp/bx/monsterdata_java_wire" + (sizePrefix ? "_sp" : "") + ".mon";
          FileChannel fc = new FileOutputStream(filename).getChannel();
          fc.write(fbb.dataBuffer().duplicate());
          fc.close();
      } catch(java.io.IOException e) {
          System.out.println("FlatBuffers test: couldn't write file");
          return;
      }

      // Test it:
      ByteBuffer dataBuffer = fbb.dataBuffer();
      if (sizePrefix) {
          testEq(ByteBufferUtil.getSizePrefix(dataBuffer) + SIZE_PREFIX_LENGTH,
                 dataBuffer.remaining());
          dataBuffer = ByteBufferUtil.removeSizePrefix(dataBuffer);
      }

      testEnums();
  }

  <T> void testEq(T a, T b) {
      if (!a.equals(b)) {
          System.out.println("" + a.getClass().getName() + " " + b.getClass().getName());
          System.out.println("FlatBuffers test FAILED: \'" + a + "\' != \'" + b + "\'");
          assert false;
          System.exit(1);
      }
  }




}
